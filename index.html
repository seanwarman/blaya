<html>
	<meta content="width=device-width, initial-scale=1" name="viewport" />
	<head>
		<script id="track-list" type="text/javascript" src="track-list.js"></script>
		<link rel="stylesheet" href="index.css">
	</head>
	<body>
    <header>
      <input id="search-input" type="input" placeholder="Search..." />
      <button
          id="target-button"
      >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 0c17.7 0 32 14.3 32 32V66.7C368.4 80.1 431.9 143.6 445.3 224H480c17.7 0 32 14.3 32 32s-14.3 32-32 32H445.3C431.9 368.4 368.4 431.9 288 445.3V480c0 17.7-14.3 32-32 32s-32-14.3-32-32V445.3C143.6 431.9 80.1 368.4 66.7 288H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H66.7C80.1 143.6 143.6 80.1 224 66.7V32c0-17.7 14.3-32 32-32zM128 256a128 128 0 1 0 256 0 128 128 0 1 0 -256 0zm128-80a80 80 0 1 1 0 160 80 80 0 1 1 0-160z"/></svg>
      </button>
    </header>
    <div id="track-list-container"></div>
		<footer>
			<div id="current-playing-text"></div>
			<audio tabindex="-1" id="player" controls>
				<source id="current-track" type="audio/mpeg"></source>
			</audio>
			<button tabindex="-1" id="prev-button" role="link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M267.5 440.6c9.5 7.9 22.8 9.7 34.1 4.4s18.4-16.6 18.4-29V96c0-12.4-7.2-23.7-18.4-29s-24.5-3.6-34.1 4.4l-192 160L64 241V96c0-17.7-14.3-32-32-32S0 78.3 0 96V416c0 17.7 14.3 32 32 32s32-14.3 32-32V271l11.5 9.6 192 160z"/></svg>
      </button>
			<button tabindex="-1" id="next-button" role="link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M52.5 440.6c-9.5 7.9-22.8 9.7-34.1 4.4S0 428.4 0 416V96C0 83.6 7.2 72.3 18.4 67s24.5-3.6 34.1 4.4l192 160L256 241V96c0-17.7 14.3-32 32-32s32 14.3 32 32V416c0 17.7-14.3 32-32 32s-32-14.3-32-32V271l-11.5 9.6-192 160z"/></svg>
      </button>
		</footer>
	</body>
	<script>
    // TODO
    // ~~Make the searchPage reset on every keypress~~
    // ~~Relaod the main page number by range so [1, page] 1 is from page is to.~~
    // Fix the target button
    // Split the search by words and do RegExp(firstWord).test(t) && RegExp(secondWord).test(t)




		const state = {
			currentTrackId: null,
      texts: [],
      throttleId: null,
      throttleGap: 500,
      page: 1,
      lazyLoadDebounce: false,
      searching: false,
      searchingPage: 1,
      previousScrollPositionY: 0,
		}

		const onClickOrEnter = cb => (e) => {
			if (e.type === "click" || e.key === "Enter") {
				cb(e)
			}
		}

    const simpleHash = str => {
      let hash = 0
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i)
        hash = (hash << 5) - hash + char
        hash &= hash
      }
      return new Uint32Array([hash])[0].toString(36)
    }

		const updateCurrentTrack = element => {
			document.getElementById(state.currentTrackId)?.classList?.remove('playing')
			state.currentTrackId = element.id
			element.classList.add('playing')
			document.getElementById('current-playing-text').innerHTML = `<div>${element.firstChild.innerText}</div><div>${element.lastChild.innerText}</div>`
		}

		const onPlay = (e) => {
			 const ref = e.currentTarget
			 if (ref) {
				const sourcer = document.getElementById('current-track')
				sourcer.src = ref.getAttribute('data-href')
				const player = document.getElementById('player')
				player.load()
				updateCurrentTrack(ref)
				player.play()
			 }
		}

		const E = (tag, text, href, i) => {
			const newEl = document.createElement(tag)

			newEl.className = 'track'
			newEl.role = 'link'
			newEl.dataset.href = href
			newEl.tabIndex = i
			newEl.id = simpleHash(text)

			const [track, album] = text.slice(9, -4).split('/').reverse()

			if (/#/.test(track) || /#/.test(album)) {
				delete newEl
				return
			}

			newEl.innerHTML = '<div class="track-name">' + track + '</div>' + (album ? '<div class="track-album">' + album + '</div>' : '')

			newEl.onclick = onClickOrEnter(onPlay)
			newEl.onkeydown = onClickOrEnter(onPlay)

			return newEl
		}

		const A = (...newEls) => {
      document.getElementById('track-list-container').append(...newEls)
      state.texts = newEls.map(({ innerText }) => innerText)
		}

		const playTrack = (element) => {
			document.getElementById('current-track').src = element.getAttribute('data-href')
			const player = document.getElementById('player')
			player.load()
			updateCurrentTrack(element)
			player.play()
		}

		const onNext = () => {
			const currentTrackEl = document.getElementById(state.currentTrackId)
			if (!currentTrackEl || currentTrackEl.hidden) return playTrack(document.querySelector('.track'))
      if (!currentTrackEl.nextElementSibling.hidden) return playTrack(currentTrackEl.nextElementSibling)

      const nextTrackIndex = Number(currentTrackEl.nextElementSibling.id.split('-')[1])
      const els = document.getElementsByClassName('track')
      for (let i = nextTrackIndex; i < els.length; i++) {
          if (!els[i].hidden) return playTrack(els[i])
      }
		}

		const onPrev = () => {
			const currentTrackEl = document.getElementById(state.currentTrackId)
			if (!currentTrackEl || currentTrackEl.hidden) return playTrack(document.querySelector('.track'))
      if (!currentTrackEl.previousElementSibling.hidden) return playTrack(currentTrackEl.previousElementSibling)

      const prevTrackIndex = Number(currentTrackEl.previousElementSibling.id.split('-')[1])
      const els = document.getElementsByClassName('track')
      for (let i = prevTrackIndex; i > -1; i--) {
          if (!els[i].hidden) return playTrack(els[i])
      }
		}

    const onScrollThisTrack = () => {

      const el = document.getElementById(state.currentTrackId)
      // el.scrollIntoView({ inline: 'center', behavior: 'smooth', block: 'center' })
      el.focus()
    }

    const hideElementsSearchMethod = (e) => {
      if (e.target.value.length === 0) {
        const elsHidden = document.querySelectorAll('.track[hidden]')
        for (let i = 0; i < elsHidden.length; i++) {
          elsHidden[i].hidden = false
        }
        return
      }

      const els = document.getElementsByClassName('track')
      state.texts.forEach((t,i) => {
        if(RegExp(e.target.value, 'i').test(t)) {
          els[i].hidden = false
        } else {
          els[i].hidden = true
        }
      })
    }

    const removeTrackEls = () => {
      document.getElementById('track-list-container').remove()

      const footer = document.getElementsByTagName('footer')[0]
			const trackListContainer = document.createElement('div')
      trackListContainer.id = 'track-list-container'
      document.body.insertBefore(trackListContainer, footer)
    }

    const injectTracks = (trackList) => {
      A(...trackList
        .filter(track =>
                !/\/$/.test(track)
          && (/.mp3$/.test(track) || /.flac$/.test(track))
        )
        .map((track, i) => E('div', track, track, i))
        .filter(Boolean)
      )
    }

    const injectTracksByPage = (pageRange, trackList) => {
      const [pageStart, pageEnd] = pageRange
      // pageEnd is our current page, loading page one would be [0, 1]
      const pageSize = 200

      const sliceArgs = [pageSize * pageStart, pageSize * pageEnd]

      injectTracks(trackList.slice(...sliceArgs))

      return pageEnd + 1
    }

    const afterSearchReset = () => {
      removeTrackEls()
      injectTracksByPage([0, state.page], trackList)
      scrollTo(0, state.previousScrollPositionY)
    }

    const onSearch = (e) => {
      // If this is the first search, remember the scroll position...
      if (!state.searching) state.previousScrollPositionY = window.scrollY
      state.searchingPage = 1

      if (e.target.value.length === 0) {
        state.searching = false
        afterSearchReset()
        return
      }

      if (state.throttleId) clearTimeout(state.throttleId)
      state.throttleId = setTimeout(() => {
        state.searching = true
        window.scrollTo(0, 0)
        removeTrackEls()
        const filteredTracks = trackList.filter(t => RegExp(e.target.value, 'i').test(t))
        injectTracksByPage([0, state.searchingPage], filteredTracks)
        //hideElementsSearchMethod(e)
      }, 100)
    }

    state.page = injectTracksByPage([0, state.page], trackList)

    window.onscroll = function(ev) {
      const offset = 5000

      if ((window.innerHeight + window.scrollY + offset) >= document.body.offsetHeight) {

        if (state.lazyLoadDebounce) return
        if (state.searching) {
          const searchEl = document.getElementById('search-input')
          if (searchEl.value.length > 0) state.searchPage = injectTracksByPage([state.searchingPage - 1, state.searchingPage], trackList.filter(t => RegExp(searchEl.value, 'i').test(t)))
        } else {
          state.page = injectTracksByPage([state.page - 1, state.page], trackList)
        }
          state.lazyLoadDebounce = true
          setTimeout(() => {
            state.lazyLoadDebounce = false
          }, 500)
      }
    }

		// Buttons...
		document.getElementById('player').onended = onNext
		document.getElementById('next-button').onclick = onClickOrEnter(onNext)
		document.getElementById('next-button').onkeydown = onClickOrEnter(onNext)
		document.getElementById('prev-button').onclick = onClickOrEnter(onPrev)
		document.getElementById('prev-button').onkeydown = onClickOrEnter(onPrev)
    document.getElementById('target-button').onclick = onClickOrEnter(onScrollThisTrack)
    document.getElementById('target-button').onkeydown = onClickOrEnter(onScrollThisTrack)

    document.getElementById('search-input').onkeydown = e => e.stopPropagation()
    document.getElementById('search-input').oninput = onSearch

		// Key commands...
		const onKey = (...maps) => e => {
			maps.forEach(([key, cb]) => {
				if(e.key === key) {
					e.preventDefault()
					cb(e)
				}
			})
		}

		document.onkeydown = onKey(
			[' ', e => {
				const player = document.getElementById('player')
				if (player.paused) {
					player.play()
				} else {
					player.pause()
				}

			}],
			['ArrowRight', onNext],
			['ArrowLeft', onPrev],
		)

	</script>
<html>
