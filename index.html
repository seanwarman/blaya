<html>
	<meta content="width=device-width, initial-scale=1" name="viewport" />
	<head>
		<link rel="stylesheet" href="index.css">
	</head>
	<body>
    <header>
      <div class="search-container">
        <label hidden for="search-input">Search</label>
        <input id="search-input" type="input" placeholder="âŒ˜ K" />
        <button tabindex="0" id="clear-search-button">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="#e2e2e2" d="M256 512c141.4 0 256-114.6 256-256S397.4 0 256 0S0 114.6 0 256S114.6 512 256 512zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"/></svg>
        </button>
      </div>
      <button id="target-button">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 0c17.7 0 32 14.3 32 32V66.7C368.4 80.1 431.9 143.6 445.3 224H480c17.7 0 32 14.3 32 32s-14.3 32-32 32H445.3C431.9 368.4 368.4 431.9 288 445.3V480c0 17.7-14.3 32-32 32s-32-14.3-32-32V445.3C143.6 431.9 80.1 368.4 66.7 288H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H66.7C80.1 143.6 143.6 80.1 224 66.7V32c0-17.7 14.3-32 32-32zM128 256a128 128 0 1 0 256 0 128 128 0 1 0 -256 0zm128-80a80 80 0 1 1 0 160 80 80 0 1 1 0-160z"/></svg>
      </button>
    </header>
    <div id="track-list-container"></div>
		<footer>
			<div tabindex="0" id="current-playing-text" role="button"></div>
			<audio tabindex="-1" id="player" controls>
				<source id="current-track" type="audio/mpeg"></source>
			</audio>
			<button id="prev-button" role="link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M267.5 440.6c9.5 7.9 22.8 9.7 34.1 4.4s18.4-16.6 18.4-29V96c0-12.4-7.2-23.7-18.4-29s-24.5-3.6-34.1 4.4l-192 160L64 241V96c0-17.7-14.3-32-32-32S0 78.3 0 96V416c0 17.7 14.3 32 32 32s32-14.3 32-32V271l11.5 9.6 192 160z"/></svg>
      </button>
			<button id="next-button" role="link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M52.5 440.6c-9.5 7.9-22.8 9.7-34.1 4.4S0 428.4 0 416V96C0 83.6 7.2 72.3 18.4 67s24.5-3.6 34.1 4.4l192 160L256 241V96c0-17.7 14.3-32 32-32s32 14.3 32 32V416c0 17.7-14.3 32-32 32s-32-14.3-32-32V271l-11.5 9.6-192 160z"/></svg>
      </button>
		</footer>
	</body>
	<script type="module">
    import { trackList } from '/track-list.js'

		const state = {
			currentTrackId: null,
      texts: [],
      throttleId: null,
      throttleGap: 500,
      page: 1,
      numberOfPages: 3,
      lazyLoadDebounce: false,
      searching: false,
      searchingPage: 1,
      previousScrollPositionY: 0,
      pageSize: 300,
      previousTrackListContainer: null,
		}

		const onClickOrEnter = cb => (e) => {
			if (e.type === "click" || e.key === "Enter") {
				cb(e)
			}
		}

    const simpleHash = str => {
      let hash = 0
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i)
        hash = (hash << 5) - hash + char
        hash &= hash
      }
      return new Uint32Array([hash])[0].toString(36)
    }

    const filter = fn => arr => arr.filter(fn)
    // Slice clones the array so sort doesn't sort in place...
    const sort = fn => arr => arr.slice().sort(fn)
    const map = fn => arr => arr.map(fn)
    const pipe = (...fns) => (...args) => fns.reduce((acc, fn) => [fn.call(null, ...acc)], args)[0]
    const breakPipe = (...fns) => (...args) => fns.reduce((acc, fn) => {
      if (acc.break) return acc
      const res = fn.call(null, ...acc.args)
      if (res === 'break') return { args: acc.args, break: true }
      return { args: [res], break: false }
    }, { args, break: false }).args[0]
    const logger = tag => (arg) => console.log(tag, arg) || arg
    const breakIf = fn => arg => fn(arg) ? 'break' : arg

		const updateCurrentTrack = element => {
			document.getElementById(state.currentTrackId)?.classList?.remove('playing')
			state.currentTrackId = element.id
			element.classList.add('playing')
			document.getElementById('current-playing-text').innerHTML = `<div>${element.firstChild.innerText}</div><div>${element.lastChild.innerText}</div>`
		}

		const onPlay = (e) => {
			 const ref = e.currentTarget
			 if (ref) {
				const sourcer = document.getElementById('current-track')
				sourcer.src = ref.getAttribute('data-href')
				const player = document.getElementById('player')
				player.load()
				updateCurrentTrack(ref)
				player.play()
			 }
		}

		const Create = (tag, text, href, i) => {
			const newEl = document.createElement(tag)
			newEl.className = 'track'
			newEl.role = 'link'
			newEl.dataset.href = href
			newEl.tabIndex = '0'
			newEl.id = simpleHash(text)

      if (newEl.id === state.currentTrackId) newEl.classList.add('playing')

			const [track, album] = text.slice(9, -4).split('/').reverse()

			if (/#/.test(track) || /#/.test(album)) {
				// delete newEl
				return
			}

			newEl.innerHTML = '<div class="track-name">' + track + '</div>' + (album ? '<div class="track-album">' + album + '</div>' : '')
			newEl.onclick = onClickOrEnter(onPlay)
			newEl.onkeydown = onClickOrEnter(onPlay)

			return newEl
		}

		const Append = (page, newEls) => {
      if (newEls.length < 1) return page
      const div = document.createElement('div')
      div.id = 'page-' + page
      div.append(...newEls)
      document.getElementById('track-list-container').append(div)
      state.texts = newEls.map(({ innerText }) => innerText)
      return page + 1
		}

		const Prepend = (page, newEls) => {
      const div = document.createElement('div')
      div.id = 'page-' + page
      div.append(...newEls)
      document.getElementById('track-list-container').prepend(div)
      state.texts = newEls.map(({ innerText }) => innerText)
      return page - 1
		}

    const trackListElements = pipe(
      filter(track =>
        !/\/$/.test(track)
        && (/.mp3$/.test(track) || /.flac$/.test(track))
      ),
      map((track, i) => Create('div', track, track, i)),
      filter(Boolean)
    )

    const appendTracks = pipe(
      (page, trackList) => Append(page, trackListElements(trackList))
    )

    const prependTracks = pipe(
      (page, trackList) => Prepend(page, trackListElements(trackList))
    )

    const indexRangeFromPages = (pageRange) => {
      const [pageStart, pageEnd] = pageRange
      // pageEnd is our current page, loading page one would be [0, 1]
      const pageSize = state.pageSize
      return [pageSize * pageStart, pageSize * pageEnd]
    }

    const pagesFromIndexRange = (indexRange) => {
      const [startIndex, endIndex] = indexRange
      const pageFromIndex = i => Math.max(1, Math.floor(startIndex / state.pageSize))
      return [pageFromIndex(startIndex), pageFromIndex(endIndex)]
    }

    const convertPageNumberToDecrease = page => (page - state.numberOfPages) - 1
    const sliceTrackListByPage = trackList => page => [page, trackList.slice(...indexRangeFromPages([page - 1, page]))]
    const appendTracksAndReturnPage = ([page, trackList]) => appendTracks(page, trackList)
    const prependTracksAndReturnPage = ([page, trackList]) => {
      prependTracks(page, trackList)
      return page + state.numberOfPages
    }

    const removeLastChildFromContainer = (arg) => {
      const trackListContainer = document.getElementById('track-list-container')
      trackListContainer.removeChild(trackListContainer.lastChild)
      return arg
    }

    const removeFirstChildFromContainer = (page) => {
      if (page > state.numberOfPages + 1) {
        const trackListContainer = document.getElementById('track-list-container')
        trackListContainer.firstChild && trackListContainer.removeChild(trackListContainer.firstChild)
      }
      return page
    }

    const removeTrackEls = (arg) => {
      document.getElementById('track-list-container').remove()
      const footer = document.getElementsByTagName('footer')[0]
			const trackListContainer = document.createElement('div')
      trackListContainer.id = 'track-list-container'
      document.body.insertBefore(trackListContainer, footer)
      return arg
    }

    const conditionsInOrder = [
      ([track, value]) => (value.split(' ').some(w => RegExp(w, 'i').test(track))),
      ([track, value]) => (RegExp(value, 'i').test(track)),
      ([track, value]) => (RegExp(value).test(track)),
      // ([track, value]) => (value.split(' ').every(w => track.toLowerCase().includes(w.toLowerCase()))),
      // ([track, value]) => (value === track),
    ]

    const searchFilter = value => track => {
      // work through conditionsInOrder backwards so that if the minimum
      // condition isn't met we discard the item
      let include = false
      for (let i = 0; i < conditionsInOrder.length - 1; i++) {
        if (conditionsInOrder[i]([track, value])) {
          include = true
          break
        }
      }
      return include
    }

    const searchFilterAndScore = value => trackList => {
      return trackList.map((track) => {
        if (value === undefined) return { track, score: 0 }
        let score = 0
        for (let i = conditionsInOrder.length - 1; i > -1; i--) {
          if (conditionsInOrder[i]([track, value])) {
            score = i
          }
        }
        return { track, score }
      })
    }

    const filterAndSortTrackList = value => breakPipe(
      filter(searchFilter(value)),
      breakIf(trackList => {
        return trackList.length > 10000
      }),
      searchFilterAndScore(value),
      sort((a,b) => {
        if (a.score < b.score) return 1
        if (a.score > b.score) return - 1
        return 0
      }),
      map(({ track }) => track)
    )

    const appendFilteredTracksByPageLazy = value => breakPipe(
      sliceTrackListByPage(
        filterAndSortTrackList(value)(trackList)
      ),
      appendTracksAndReturnPage,
      breakIf(page => page === state.searchingPage),
      removeFirstChildFromContainer,
    )

    const prependFilteredTracksByPageLazy = value => pipe(
      convertPageNumberToDecrease,
      sliceTrackListByPage(filterAndSortTrackList(value)(trackList)),
      prependTracksAndReturnPage,
      removeLastChildFromContainer,
    )

    const appendTracksByPageFilteredBy = value => pipe(
      sliceTrackListByPage(filterAndSortTrackList(value)(trackList)),
      appendTracksAndReturnPage,
    )

    const appendTracksByPageLazy = pipe(
      sliceTrackListByPage(trackList),
      appendTracksAndReturnPage,
      removeFirstChildFromContainer,
    )

    const prependTracksByPageLazy = pipe(
      convertPageNumberToDecrease,
      sliceTrackListByPage(trackList),
      prependTracksAndReturnPage,
      removeLastChildFromContainer,
    )

    const appendTracksByPage = pipe(
      sliceTrackListByPage(trackList),
      appendTracksAndReturnPage,
    )

    const replaceAllWithThreePages = pipe(
      removeTrackEls,
      appendTracksByPage,
      appendTracksByPage,
      appendTracksByPage,
    )

    const scrollToTrackByTrackId = trackId => {
      const trackListIndex = trackList.findIndex(track => trackId === simpleHash(track))
      const [page] = pagesFromIndexRange([trackListIndex, 0])
      state.page = replaceAllWithThreePages(page)
      let el = document.getElementById(trackId)
      el.focus()
    }

		const playTrack = (element) => {
			document.getElementById('current-track').src = element.getAttribute('data-href')
			const player = document.getElementById('player')
			player.pause()
			player.load()
			updateCurrentTrack(element)
			player.play()
		}

		const onNext = () => {
			const currentTrackEl = document.getElementById(state.currentTrackId)
			if (!currentTrackEl || currentTrackEl.hidden) return playTrack(document.querySelector('.track'))
      if (!currentTrackEl.nextElementSibling.hidden) return playTrack(currentTrackEl.nextElementSibling)
      const nextTrackIndex = Number(currentTrackEl.nextElementSibling.id.split('-')[1])
      const els = document.getElementsByClassName('track')
      for (let i = nextTrackIndex; i < els.length; i++) {
        if (!els[i].hidden) return playTrack(els[i])
      }
		}

		const onPrev = () => {
			const currentTrackEl = document.getElementById(state.currentTrackId)
			if (!currentTrackEl || currentTrackEl.hidden) return playTrack(document.querySelector('.track'))
      if (!currentTrackEl.previousElementSibling.hidden) return playTrack(currentTrackEl.previousElementSibling)
      const prevTrackIndex = Number(currentTrackEl.previousElementSibling.id.split('-')[1])
      const els = document.getElementsByClassName('track')
      for (let i = prevTrackIndex; i > -1; i--) {
          if (!els[i].hidden) return playTrack(els[i])
      }
		}

    const onScrollThisTrack = () => {
      scrollToTrackByTrackId(state.currentTrackId)
    }

    const hideElementsSearchMethod = (e) => {
      if (e.target.value.length === 0) {
        const elsHidden = document.querySelectorAll('.track[hidden]')
        for (let i = 0; i < elsHidden.length; i++) {
          elsHidden[i].hidden = false
        }
        return
      }
      const els = document.getElementsByClassName('track')
      state.texts.forEach((t,i) => {
        if(RegExp(e.target.value, 'i').test(t)) {
          els[i].hidden = false
        } else {
          els[i].hidden = true
        }
      })
    }

    const afterSearchReset = () => {
      state.searching = false
      document.getElementById('track-list-container').remove()
      const footer = document.getElementsByTagName('footer')[0]
      document.body.insertBefore(state.previousTrackListContainer, footer)
      scrollTo(0, state.previousScrollPositionY)
    }

    const onClearSearch = () => {
      document.getElementById('search-input').value = ''
      afterSearchReset()
    }

    const onSearch = (e) => {
      // If this is the first search, remember the scroll position...
      if (!state.searching) {
        state.previousScrollPositionY = window.scrollY
        state.previousTrackListContainer = document.getElementById('track-list-container').cloneNode(true)
      }
      state.searchingPage = 1
      if (e.target.value.length === 0) {
        afterSearchReset()
        return
      }
      if (state.throttleId) clearTimeout(state.throttleId)
      state.throttleId = setTimeout(() => {
        state.searching = true
        window.scrollTo(0, 0)
        removeTrackEls()
        state.searchingPage = appendTracksByPageFilteredBy(e.target.value)(state.searchingPage)
      }, 100)
    }

    // BEGIN
    state.page = appendTracksByPage(1)

    const setDebounce = () => {
      state.lazyLoadDebounce = true
      setTimeout(() => { state.lazyLoadDebounce = false }, 500)
    }

    window.onscroll = function(ev) {
      if (state.lazyLoadDebounce) {
        return
      }

      const offset = 3000
      const searchElValue = () => document.getElementById('search-input')?.value || ''

      // Down scroll
      if ((window.innerHeight + window.scrollY + offset) >= document.body.offsetHeight) {
        if (state.searching) {
          if (searchElValue().length > 0) {
            const searchingPage = appendFilteredTracksByPageLazy(searchElValue())(state.searchingPage)
            state.searchingPage = searchingPage || state.searchingPage
            return setDebounce()
          }
        } else {
          state.page = appendTracksByPageLazy(state.page)
          return setDebounce()
        }
      }

      // Up scroll
      if (
        !state.searching
        && state.page > state.numberOfPages + 1
        && window.scrollY < offset
      ) {
        state.page = prependTracksByPageLazy(state.page)
        return setDebounce()
      }

      if (
        state.searching
        && state.searchingPage > state.numberOfPages + 1
        && window.scrollY < offset
        && searchElValue().length > 0
      ) {
        state.searchingPage = prependFilteredTracksByPageLazy(searchElValue())(state.searchingPage)
        return setDebounce()
      }
    }

		// Buttons...
		document.getElementById('player').onended = onNext
		document.getElementById('next-button').onclick = onClickOrEnter(onNext)
		document.getElementById('next-button').onkeydown = onClickOrEnter(onNext)
		document.getElementById('prev-button').onclick = onClickOrEnter(onPrev)
		document.getElementById('prev-button').onkeydown = onClickOrEnter(onPrev)
    document.getElementById('target-button').onclick = onClickOrEnter(onScrollThisTrack)
    document.getElementById('target-button').onkeydown = onClickOrEnter(onScrollThisTrack)
    document.getElementById('current-playing-text').onclick = onClickOrEnter(onScrollThisTrack)
    document.getElementById('current-playing-text').onkeydown = onClickOrEnter(onScrollThisTrack)
    document.getElementById('search-input').onkeydown = e => e.stopPropagation()
    document.getElementById('search-input').oninput = onSearch
    document.getElementById('clear-search-button').onclick = onClickOrEnter(onClearSearch)
    document.getElementById('clear-search-button').onkeydown = onClickOrEnter(onClearSearch)

		// Key commands...
		const onKey = (...maps) => e => {
			maps.forEach(([key, cb]) => {
      if(
        (typeof key === 'string' && e.key === key)
        || (key.key === e.key && key.ctrlKey === e.ctrlKey)
        || (key.key === e.key && key.metaKey === e.metaKey)
      ) {
					e.preventDefault()
					cb(e)
				}
			})
		}

		document.onkeydown = onKey(
			[' ', e => {
				const player = document.getElementById('player')
				if (player.paused) {
					player.play()
				} else {
					player.pause()
				}
			}],
			['ArrowRight', onNext],
			['ArrowLeft', onPrev],
      [{ key: 'k', ctrlKey: true }, () => document.getElementById('search-input').focus()],
      [{ key: 'k', metaKey: true }, () => document.getElementById('search-input').focus()],
      ['Escape', () => document.getElementById('search-input').blur()],
		)

	</script>
<html>
